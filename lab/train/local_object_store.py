# AUTOGENERATED! DO NOT EDIT! File to edit: dev/05_local_object_store.ipynb (unless otherwise specified).

__all__ = ['white_list', 'merge_config', 'WHITE_LIST_CONFIG', 'root', 'name', 'bucket_filter', 'ROOT', 'list_buckets',
           'find_or_create_bucket', 'remove_bucket']

# Cell
from ..imports import *

# Cell

WHITE_LIST_CONFIG = ['root', 'name', 'filter', 'force']

def white_list(keywords, keys, require_keys=False, expand_missing=False):
    """Filter a dictionary by a set of keys"""
    if require_keys:
        return {key:keywords[key] for key in keys}
    if expand_missing:
        return {key:keywords.get(key) for key in keys}
    result = {}
    for key in keys:
        if key in keywords: result[key] = keywords[key]
    return result

def merge_config(**kw):
    """Get the local environemnt variables, convert the keys
    to lower case, merge new keywords over the environment
    variables, and use a white list filter on valid entries.

    Right now, I'm only white listing the environment variables,
    but possibly I'll do this for everything."""

    env = {k.lower():v for k, v in os.environ.items()}
    env = white_list(env, WHITE_LIST_CONFIG)
    return {**env, **kw}

# Cell

ROOT = '/tmp'
def root(**kw):
    kw = merge_config(**kw)
    return Path(kw.get('root', ROOT))

def _is_re(o):
    """In 3.6.9, the type is different."""
    return hasattr(o, 'match') and hasattr(o, 'pattern')

def name(**kw):
    kw = merge_config(**kw)
    o = kw.get('name', kw.get('filter', None))
    if _is_re(o):
        return o.pattern
    if o is None or isinstance(o, str):
        return o
    return str(o)

def bucket_filter(**kw):
    kw = merge_config(**kw)
    o = kw.get('name', kw.get('filter', ''))
    if _is_re(o): return o
    return re.compile(f".*{o}.*")

# Cell

def _list_paths(**kw):
    r = root(**kw)
    p = bucket_filter(**kw)
    return [f for f in r.iterdir() if f.is_dir() and p.match(f.name)]

def list_buckets(**kw):
    return [p.name for p in _list_paths(**kw)]

def _get_slice(seq, key, default=None):
    d = dict(enumerate(seq))
    return d.get(key, default)

def _first_path(**kw):
    return _get_slice(list_paths(**kw), 0)

def _first_bucket(**kw):
    return _get_slice(list_buckets(**kw), 0)

def _exists(**kw):
    found = _first_path(**kw)
    return not found is None and found.exists()

def _is_empty(**kw):
    if not _exists(**kw): return True
    return len(list(_first_path(**kw).glob('*'))) == 0

def _can_remove_bucket(**kw):
    kw = merge_config(**kw)
    if _is_empty(**kw): return True
    if kw.get('force', False): return True
    return False

def _full_path(**kw):
    return root(**kw)/name(**kw)

def find_or_create_bucket(**kw):
    path = _full_path(**kw)
    path.mkdir(parents=True, exist_ok=True)
    return path.name

def remove_bucket(**kw):
    if not can_remove_bucket(**kw): return False
    try:
        path = _full_path(**kw)
        shutil.rmtree(path)
        return True
    except:
        return False