# AUTOGENERATED! DO NOT EDIT! File to edit: dev/03_local_object_store.ipynb (unless otherwise specified).

__all__ = ['white_list', 'merge_config', 'WHITE_LIST_CONFIG', 'ROOT', 'list_buckets', 'find_or_create_bucket',
           'remove_bucket']

# Cell
from ..imports import *
import .protocols
import random

# Cell

WHITE_LIST_CONFIG = ['root', 'name', 'filter', 'force']

def white_list(keywords, keys, require_keys=False, expand_missing=False):
    """Filter a dictionary by a set of keys"""
    if require_keys:
        return {key:keywords[key] for key in keys}
    if expand_missing:
        return {key:keywords.get(key) for key in keys}
    result = {}
    for key in keys:
        if key in keywords: result[key] = keywords[key]
    return result

def merge_config(**kw):
    """Get the local environemnt variables, convert the keys
    to lower case, merge new keywords over the environment
    variables, and use a white list filter on valid entries.

    Right now, I'm only white listing the environment variables,
    but possibly I'll do this for everything."""

    env = {k.lower():v for k, v in os.environ.items()}
    env = white_list(env, WHITE_LIST_CONFIG)
    return {**env, **kw}

# Cell

ROOT = '/tmp'
def _root(**kw):
    """Expose root from the config or a default."""
    kw = merge_config(**kw)
    return Path(kw.get('root', ROOT))

def _is_re(o):
    """Deal with whether an object is a regular expression.
    Modern Python uses re.Pattern for all compiled regular
    expressions, but in 3.6.9 and ostensibly before, I don't
    have this. So, duck type it: if it has match and pattern,
    good enough."""
    return hasattr(o, 'match') and hasattr(o, 'pattern')

def _name(**kw):
    """Name is gathered from the configuration or keyword
    arguments. It uses name or filter, because both keys
    make sense with different calls. Name is used
    for the bucket or item name, depending on the context."""
    kw = merge_config(**kw)
    o = kw.get('name', kw.get('filter', None))
    if _is_re(o):
        return o.pattern
    if o is None or isinstance(o, str):
        return o
    return str(o)

def _bucket_filter(**kw):
    kw = merge_config(**kw)
    o = kw.get('name', kw.get('filter', ''))
    if _is_re(o): return o
    return re.compile(f".*{o}.*")

# Cell

def _list_paths(**kw):
    """In the local object store, a directory is a bucket.
    Find all directories, given an optional filter."""
    r = _root(**kw)
    p = _bucket_filter(**kw)
    return [f for f in r.iterdir() if f.is_dir() and p.match(f.name)]

def list_buckets(**kw):
    """Convert found directories to just their names."""

    # TODO: Consider expanding this to a sequence of bucket types,
    # after working through this interface and the MinIO one.
    return [p.name for p in _list_paths(**kw)]

def _get_slice(seq, key, default=None):
    """Get key from a sequence, returning a default.
    This is the same as d.get(key, default), but allowing
    a slice instead of just a key (so _get_slice(a, slice(2:4))
    works).
    Note: I use this here on sequences, rather than maps,
    a quick way to say something like a[0] when a is
    potentially empty."""
    d = dict(enumerate(seq))
    return d.get(key, default)

def _first_path(**kw):
    """What's the first path filtered from root, default None."""
    return _get_slice(_list_paths(**kw), 0)

def _first_bucket(**kw):
    "What's the first directory name filtered from root, default None."
    return _get_slice(list_buckets(**kw), 0)

def _exists(**kw):
    """Does a directory exist, given a filter?"""
    found = _first_path(**kw)
    return not found is None and found.exists()

def _is_empty(**kw):
    """Are there contents inside the directory?
    Returns True (is empty) when the directory doesn't exist."""
    if not _exists(**kw): return True
    return len(list(_first_path(**kw).glob('*'))) == 0

def _can_remove_bucket(**kw):
    kw = merge_config(**kw)
    if _is_empty(**kw): return True
    if kw.get('force', False): return True
    return False

def _full_path(**kw):
    return root(**kw)/name(**kw)

def find_or_create_bucket(**kw):
    path = _full_path(**kw)
    path.mkdir(parents=True, exist_ok=True)
    return path.name

def remove_bucket(**kw):
    if not _can_remove_bucket(**kw): return False
    try:
        path = _full_path(**kw)
        shutil.rmtree(path)
        return True
    except:
        return False