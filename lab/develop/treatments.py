# AUTOGENERATED! DO NOT EDIT! File to edit: dev/02.00.develop.treatments.ipynb (unless otherwise specified).

__all__ = ['PASSING_STATUS', 'FAILING_STATUS', 'Validate', 'validate']

# Cell
from ..imports import *
import ..object_store.noop as noop_object_store
import math

# Cell
PASSING_STATUS = 'passed'
FAILING_STATUS = 'failed'

def _create_step(name, message=None, status=PASSING_STATUS, **kw):
    """Create a step. A step is just a dictionary with some conventions.
    Default to passed and no message."""
    d = {**kw, **dict(name=name, status=status)}
    if not message is None: d['message'] = message
    return d

_pass_step = _create_step # Default is pass

def _fail_step(name, exception=None, **kw):
    """Create a failing step using an exception.
    It's common to pass a traceback to this function, but it's not
    necessary, or even used in the current state of anything."""
    return _create_step(name, status=FAILING_STATUS, message=str(exception), **kw)


# Cell

class Validate:
    """Validate a Treatment"""

    DEFAULT_STEPS = [
        ('setup model', 'fn'),
        ('configure model', 'model'),
        ('duck type', 'valid_duck_type')
    ]

    @classmethod
    def call(cls, **kw):
        return cls(**kw)()

    def __init__(self, **kw):
        self.kw = kw

    @property
    def steps(self):
        if hasattr(self, '_steps'): return self._steps
        self._steps = self.kw.get('steps', self.DEFAULT_STEPS)
        return self._steps

    @property
    def name(self):
        """Get the name of the treatment."""
        if hasattr(self, '_name'): return self._name
        self._name = self.kw.get('name')
        return self._name

    @property
    def package(self):
        """Reveal the string of a package, if provided."""
        if hasattr(self, '_package'): return self._package
        self._package = self.kw.get('package')
        return self.package

    @property
    def loaded_package(self):
        """Reveal the imported package, if provided."""
        if hasattr(self, '_loaded_package'): return self._loaded_package
        if self.package is None: return None
        try:
            self._loaded_package = __import__(self.package)
            return self._loaded_package
        except:
            self._loaded_package = None

    @property
    def fn(self):
        if hasattr(self, '_fn'): return self._fn
        g = globals()
        if 'fn' in self.kw and self.kw['fn'] in g:
            self._fn = g[self.kw['fn']]
        if self.name:
            if self.name in g:
                self._fn = g[self.name]
            if self.loaded_package and hasattr(self.loaded_package, self.name):
                self._fn = getattr(self.loaded_package, self.name)
        if not hasattr(self, '_fn'): self._fn = None
        return self._fn

    @property
    def unused_keywords(self):
        """Sloppy way to use keywords for both validation and model building."""
        if hasattr(self, '_unused_keywords'): return self._unused_keywords
        known = ['steps', 'name', 'package'] # keywords used in validation, not model building
        self._unused_keywords = {k:v for k, v in self.kw.items() if not k in known}
        return self._unused_keywords

    @property
    def model(self):
        """Construct a model from the unused keywords."""
        # TODO: Revisit this, it might not be what I want.
        if hasattr(self, '_model'): return self._model
        self._model = self.fn()(**self.unused_keywords)
        return self._model

    @property
    def valid_duck_type(self):
        """TODO: write validations that the model is usable."""
        return True

    def validate(self):
        """Run the steps to validate."""
        results = []
        for (name, attribute) in self.steps:
            try:
                passing = bool(getattr(self, attribute))
                result = _pass_step(name) if passing else _fail_step(name)
                results.append(result)
            except Exception as e:
                _, _, exc_traceback = sys.exc_info()
                results.append(_fail_step(name, exception=e, traceback=exc_traceback))
        passing = all([d.get('status') == PASSING_STATUS for d in results])
        return passing, results

    def __call__(self):
        return self.validate()

def validate(**kw): return Validate.call(**kw)