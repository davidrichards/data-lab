# AUTOGENERATED! DO NOT EDIT! File to edit: dev/02.00.develop.treatments.ipynb (unless otherwise specified).

__all__ = ['PASSING_STATUS', 'FAILING_STATUS', 'Validate', 'validate', 'listify', 'ValidateRecord', 'validate_records',
           'store', 'start', 'increment_version', 'string_version', 'revise']

# Cell
from ..imports import *
import ..object_store.noop as noop_object_store
import math # For testing
import getpass

# Cell
PASSING_STATUS = 'passed'
FAILING_STATUS = 'failed'

def _create_step(name, message=None, status=PASSING_STATUS, **kw):
    """Create a step. A step is just a dictionary with some conventions.
    Default to passed and no message."""
    d = {**kw, **dict(name=name, status=status)}
    if not message is None: d['message'] = message
    return d

_pass_step = _create_step # Default is pass

def _fail_step(name, exception=None, **kw):
    """Create a failing step using an exception.
    It's common to pass a traceback to this function, but it's not
    necessary, or even used in the current state of anything."""
    return _create_step(name, status=FAILING_STATUS, message=str(exception), **kw)


# Cell

class Validate:
    """Validate a Treatment"""

    DEFAULT_STEPS = [
        ('setup model', 'fn'),
        ('configure model', 'model'),
        ('duck type', 'valid_duck_type')
    ]

    @classmethod
    def call(cls, **kw):
        return cls(**kw)()

    def __init__(self, **kw):
        self.kw = kw

    @property
    def steps(self):
        if hasattr(self, '_steps'): return self._steps
        self._steps = self.kw.get('steps', self.DEFAULT_STEPS)
        return self._steps

    @property
    def name(self):
        """Get the name of the treatment."""
        if hasattr(self, '_name'): return self._name
        self._name = self.kw.get('name')
        return self._name

    @property
    def package(self):
        """Reveal the string of a package, if provided."""
        if hasattr(self, '_package'): return self._package
        self._package = self.kw.get('package')
        return self.package

    @property
    def loaded_package(self):
        """Reveal the imported package, if provided."""
        if hasattr(self, '_loaded_package'): return self._loaded_package
        if self.package is None: return None
        try:
            self._loaded_package = __import__(self.package)
            return self._loaded_package
        except:
            self._loaded_package = None

    @property
    def fn(self):
        if hasattr(self, '_fn'): return self._fn
        g = globals()
        if 'fn' in self.kw and self.kw['fn'] in g:
            self._fn = g[self.kw['fn']]
        if self.name:
            if self.name in g:
                self._fn = g[self.name]
            if self.loaded_package and hasattr(self.loaded_package, self.name):
                self._fn = getattr(self.loaded_package, self.name)
        if not hasattr(self, '_fn'): self._fn = None
        return self._fn

    @property
    def unused_keywords(self):
        """Sloppy way to use keywords for both validation and model building."""
        if hasattr(self, '_unused_keywords'): return self._unused_keywords
        known = ['steps', 'name', 'package'] # keywords used in validation, not model building
        self._unused_keywords = {k:v for k, v in self.kw.items() if not k in known}
        return self._unused_keywords

    @property
    def model(self):
        """Construct a model from the unused keywords."""
        # TODO: Revisit this, it might not be what I want.
        if hasattr(self, '_model'): return self._model
        self._model = self.fn()(**self.unused_keywords)
        return self._model

    @property
    def valid_duck_type(self):
        """TODO: write validations that the model is usable."""
        return True

    def validate(self):
        """Run the steps to validate."""
        results = []
        for (name, attribute) in self.steps:
            try:
                passing = bool(getattr(self, attribute))
                result = _pass_step(name) if passing else _fail_step(name)
                results.append(result)
            except Exception as e:
                _, _, exc_traceback = sys.exc_info()
                results.append(_fail_step(name, exception=e, traceback=exc_traceback))
        passing = all([d.get('status') == PASSING_STATUS for d in results])
        return passing, results

    def __call__(self):
        return self.validate()

def validate(**kw): return Validate.call(**kw)

# Cell

def listify(o):
    """Create lists from objects"""
    if o is None: return []
    if isinstance(o, list): return o
    if isinstance(o, str): return [o]
    if isinstance(o, dict): return [o]
    if isinstance(o, Iterable): return list(o)
    return [o]

class ValidateRecord:
    """Given the state of a treatment record, the data we record around the code,
    is it valid? The Validate code deals with whether the validation should work
    with our environment. This code deals with whether we're setting the right
    attributes in the database."""

    BASIC_PROPERTIES = ['name', 'version', 'contributors', 'state', 'created_at', 'updated_at']
    REQUIRED_MAP = dict(
        started = BASIC_PROPERTIES,
        revised = BASIC_PROPERTIES,
        validated = BASIC_PROPERTIES + ['class'],
        production = BASIC_PROPERTIES + ['class', 'expectations', 'invocation'],
        retired = BASIC_PROPERTIES,
    )

    ADDITIONAL_PROPERTIES = ['package', 'description', 'target_release']

    ALLOWED_MAP = dict(
        started = REQUIRED_MAP['started'] + ADDITIONAL_PROPERTIES,
        revised = REQUIRED_MAP['revised'] + ADDITIONAL_PROPERTIES,
        validated = REQUIRED_MAP['validated'] + ADDITIONAL_PROPERTIES,
        production = REQUIRED_MAP['production'] + ADDITIONAL_PROPERTIES,
        retired = REQUIRED_MAP['retired'] + ADDITIONAL_PROPERTIES + ['replacement'],
    )

    DEFAULT_VERSION = dict(
        major = 0,
        minor = 0,
        patch = 1,
    )

    @classmethod
    def call(cls, **kw):
        return cls(**kw)()

    def __init__(self, **kw):
        self.kw = kw

    @property
    def state(self):
        return self.kw.get('state', list(self.REQUIRED_MAP.keys())[0])

    @property
    def config(self):
        if hasattr(self, '_config'): return self._config
        self._config = self.kw.get('config', {})
        return self._config

    @property
    def user(self):
        if hasattr(self, '_user'): return self._user
        self._user = self.config.get('user', getpass.getuser())
        return self._user

    @property
    def contributors(self):
        if hasattr(self, '_contributors'): return self._contributors
        contributors = listify(self.kw.get('contributors', []))
        if not self.user in contributors: contributors += [self.user]
        self._contributors = contributors
        return self._contributors

    @property
    def version(self):
        if hasattr(self, '_version'): return self._version
        version = self.kw.get('version', self.DEFAULT_VERSION)
        if isinstance(version, str):
            d = dict(enumerate(version.split('.')))
            version = dict(
                major = d.get(0, self.DEFAULT_VERSION['major']),
                minor = d.get(1, self.DEFAULT_VERSION['minor']),
                patch = d.get(2, self.DEFAULT_VERSION['patch']),
            )
        self._version = version
        return self._version

    @property
    def now(self):
        if hasattr(self, '_now'): return self._now
        self._now = self.kw.get('now', datetime.utcnow())
        return self._now

    @property
    def created_at(self):
        return self.kw.get('created_at', self.now)

    @property
    def updated_at(self):
        return self.kw.get('updated_at', self.now)

    def _has_field(self, key):
        return hasattr(self, key) or key in self.kw

    def _get_field(self, key):
        if hasattr(self, key): return getattr(self, key)
        return self.kw.get(key)

    def _get_fields(self, keys):
        return {key:self._get_field(key) for key in keys if self._has_field(key)}

    @property
    def attributes(self):
        """The available attributes for the state."""
        if hasattr(self, '_attributes'): return self._attributes
        assert self.state in self.ALLOWED_MAP, f"Invalid state: {self.state}. Must by one of {list(self.ALLOWED_MAP.keys())}"
        self._attributes = self._get_fields(self.ALLOWED_MAP[self.state])
        return self._attributes

    @property
    def state_based_conditions(self):
        validate_states = ['validated', 'production']
        if not self.state in validate_states: return True
        validator = Validate(**self.attributes)
        valid, _ = validator()
        return valid

    @property
    def valid(self):
        """Do we have the required attributes for the state? """
        if hasattr(self, '_valid'): return self._valid
        assert self.state in self.REQUIRED_MAP, f"Invalid state: {self.state}. Must by one of {list(self.REQUIRED_MAP.keys())}"
        found = [key in self.attributes for key in self.REQUIRED_MAP[self.state]]
        self._valid = all(found) and self.state_based_conditions
        return self._valid

    def __call__(self):
        return self.valid, self.attributes

def validate_records(**kw): return ValidateRecord.call(**kw)

# Cell

def store(object_store=noop_object_store, **kw):
    """Store the record, if valid, in the provided object store. Defaults to a noop data store."""
    valid, record = ValidateRecord.call(**kw)
    if not valid:
        return False
    return object_store.put(item=record, **record)

def start(**kw):
    """Start a new record, ensuring the state is correct."""
    kw = {**kw, **{'state': 'started'}}
    return store(**kw)

def increment_version(version, level='patch', **kw):
    levels = ['major', 'minor', 'patch']
    if not level in levels: level = 'patch'
    if version is None: version = "0.0.0"
    if isinstance(version, str):
        d = dict(enumerate(version.split('.')))
        version = dict(
            major = d.get(0, 0),
            minor = d.get(1, 0),
            patch = d.get(2, 0),
        )
    assert isinstance(version, dict), "Version must be a dictionary or convertible to a dictionary."
    version = {k:int(version.get(k, 0)) for k in levels}
    version[level] += 1
    if level == 'major':
        version['minor'] = 0
        version['patch'] = 0
    if level == 'minor':
        version['patch'] = 0
    return version

def string_version(version, **kw):
    "Convert a dictionary version to a string format"
    if isinstance(version, str): return version
    if isinstance(version, dict):
        return f"{version.get('major', 0)}.{version.get('minor', 0)}.{version.get('patch', 0)}"

def revise(name, item=None, object_store=noop_object_store, **kw):
    """Revise a record, using the name to find the old record, if it exists."""
    if item is None: item = {'name': name} # For testing
    now = kw.pop('now', datetime.utcnow())
    record = object_store.get(name=name, item=item)
    old_version = record.get('version', None)
    new_version = increment_version(old_version)
    record['version'] = new_version
    record['state'] = 'revised'
    record['updated_at'] = now
    kw = {**record, **kw, **{'object_store': object_store}}
    return store(**kw, item=record)