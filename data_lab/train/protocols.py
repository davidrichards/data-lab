# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02_protocols.ipynb (unless otherwise specified).

__all__ = ['serialize', 'deserialize', 'compress', 'decompress', 'to_dict', 'DEFAULT_COMPRESSION', 'COMPRESSION_LEVELS',
           'MessageBuilder', 'subject_builder', 'treatment_builder', 'model_builder', 'evaluation_builder',
           'expectation_builder', 'invocation_builder']

# Cell
from lab.imports import *

# Cell
def serialize(message):
    """Convert a message to a binary string."""
    return message.SerializeToString()

def _kind_to_class(kind, parent=training_prototypes):
    """Find a Message class by reference.
    Allows a recursive search for a message class.
    The message I used to test this no longer exists."""
    if isinstance(kind, type): return kind
    if isinstance(kind, str):
        kind, *tail = kind.split('.')
        if hasattr(parent, kind):
            if len(tail) > 0:
                parent = _kind_to_class(kind, parent=parent)
                if parent:
                    return _kind_to_class('.'.join(tail), parent=parent)
            return _kind_to_class(getattr(parent, kind))

def deserialize(s, kind):
    """Deserialize a string as a kind of message."""
    cls = _kind_to_class(kind)
    if cls is None: return False
    message = cls()
    message.ParseFromString(s)
    return message

DEFAULT_COMPRESSION = zlib.Z_BEST_COMPRESSION
COMPRESSION_LEVELS = dict(
    best_speed=zlib.Z_BEST_SPEED,
    best_compression=zlib.Z_BEST_COMPRESSION,
    default=zlib.Z_DEFAULT_COMPRESSION,
)

def compress(message, level=DEFAULT_COMPRESSION):
    """Compress a message."""
    if isinstance(level, str): level = COMPRESSION_LEVELS.get(level, DEFAULT_COMPRESSION)
    s = serialize(message)
    return zlib.compress(s, level)

def decompress(compressed, kind):
    """Decompress a compressed message, given the kind of message."""
    cls = _kind_to_class(kind)
    if cls is None: return False
    decompressed = zlib.decompress(compressed)
    return deserialize(decompressed, cls)

def to_dict(message):
    """Create a dictionary from a message, including all defaults."""
    fields = dict(message.DESCRIPTOR.fields_by_name)
    return {k:getattr(message, k) for k in fields.keys()}

# Cell
class MessageBuilder:
    """Create Protocol Buffer messages from Python
    data types."""

    DEFAULT_MESSAGE_CLASS = training_prototypes.Model

    def __init__(self, **kw):
        self.kw = kw

    def _class_from_object(self, o):
        return _kind_to_class(o)

    @property
    def _message_class(self):
        if hasattr(self, '__message_class'): return self.__message_class
        o = self.kw.get('kind', self.DEFAULT_MESSAGE_CLASS)
        self.__message_class = _kind_to_class(o)
        return self.__message_class

    @property
    def instance(self):
        if hasattr(self, '_instance'): return self._instance
        self._instance = self._message_class()
        return self._instance

    @property
    def _fields(self):
        if hasattr(self, '__fields'): return self.__fields
        self.__fields = dict(self._message_class.DESCRIPTOR.fields_by_name)
        return self.__fields

    def build(self, data):
        # TODO: add recursion and type checking.
        data = {k:v for k, v in data.items() if k in self._fields}
        try:
            return self._message_class(**data)
        except:
            # Something is wrong...just ignore it for now...
            pass

    def __call__(self, **data):
        return self.build(data)

subject_builder = MessageBuilder(kind='Subject')
treatment_builder = MessageBuilder(kind='Treatment')
model_builder = MessageBuilder(kind='Model')
evaluation_builder = MessageBuilder(kind='Evaluation')
expectation_builder = MessageBuilder(kind='Expectation')
invocation_builder = MessageBuilder(kind='Invocation')